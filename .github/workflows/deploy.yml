name: Deploy to Environments

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version/tag to deploy'
        required: true
        default: 'main'

env:
  REGISTRY: ghcr.io

jobs:
  # Deploy to staging environment
  deploy-staging:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment:
      name: staging
      url: https://staging.your-domain.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Deploy to ECS Staging
      run: |
        # Update ECS service with new image
        VERSION=${{ github.event.inputs.version || github.ref_name }}

        # Update task definition with new images
        aws ecs describe-task-definition \
          --task-definition project-template-staging \
          --query taskDefinition > task-def.json

        # Update container images
        jq --arg IMAGE "${{ env.REGISTRY }}/${{ github.repository }}/api:$VERSION" \
           '.containerDefinitions[0].image = $IMAGE' task-def.json > temp.json && mv temp.json task-def.json

        jq --arg IMAGE "${{ env.REGISTRY }}/${{ github.repository }}/web:$VERSION" \
           '.containerDefinitions[1].image = $IMAGE' task-def.json > temp.json && mv temp.json task-def.json

        # Remove unnecessary fields
        jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' \
           task-def.json > task-def-clean.json

        # Register new task definition
        aws ecs register-task-definition \
          --cli-input-json file://task-def-clean.json

        # Update service
        aws ecs update-service \
          --cluster project-template-staging \
          --service project-template-staging-service \
          --task-definition project-template-staging

        # Wait for deployment to complete
        aws ecs wait services-stable \
          --cluster project-template-staging \
          --services project-template-staging-service

    - name: Run health checks
      run: |
        # Wait for service to be healthy
        sleep 60

        # Check health endpoints
        curl -f https://staging.your-domain.com/health
        curl -f https://staging.your-domain.com/api/v1/status

        echo "Staging deployment successful"

    - name: Run smoke tests
      run: |
        # Run basic smoke tests against staging
        python tests/smoke/staging_tests.py || true

  # Deploy to production environment
  deploy-production:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment:
      name: production
      url: https://your-domain.com
    needs: []  # Remove staging dependency for manual deploys

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Blue-Green Deployment
      run: |
        VERSION=${{ github.event.inputs.version || github.ref_name }}

        # Create new task definition
        aws ecs describe-task-definition \
          --task-definition project-template-prod \
          --query taskDefinition > task-def.json

        # Update container images
        jq --arg IMAGE "${{ env.REGISTRY }}/${{ github.repository }}/api:$VERSION" \
           '.containerDefinitions[0].image = $IMAGE' task-def.json > temp.json && mv temp.json task-def.json

        jq --arg IMAGE "${{ env.REGISTRY }}/${{ github.repository }}/web:$VERSION" \
           '.containerDefinitions[1].image = $IMAGE' task-def.json > temp.json && mv temp.json task-def.json

        # Clean up task definition
        jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' \
           task-def.json > task-def-clean.json

        # Register new task definition
        NEW_REVISION=$(aws ecs register-task-definition \
          --cli-input-json file://task-def-clean.json \
          --query 'taskDefinition.revision')

        echo "New task definition revision: $NEW_REVISION"

        # Get current service configuration
        CURRENT_TASK_DEF=$(aws ecs describe-services \
          --cluster project-template-prod \
          --services project-template-prod-service \
          --query 'services[0].taskDefinition' --output text)

        echo "Current task definition: $CURRENT_TASK_DEF"

        # Create temporary green service
        aws ecs create-service \
          --cluster project-template-prod \
          --service-name project-template-prod-green \
          --task-definition project-template-prod:$NEW_REVISION \
          --desired-count 2 \
          --load-balancers targetGroupArn=${{ secrets.TARGET_GROUP_ARN }},containerName=api,containerPort=8080

        # Wait for green service to be stable
        aws ecs wait services-stable \
          --cluster project-template-prod \
          --services project-template-prod-green

        # Health check green service
        sleep 30
        curl -f https://your-domain.com/health

        # Switch traffic to green service
        aws elbv2 modify-target-group \
          --target-group-arn ${{ secrets.TARGET_GROUP_ARN }} \
          --health-check-path /health

        # Scale down blue service
        aws ecs update-service \
          --cluster project-template-prod \
          --service project-template-prod-service \
          --desired-count 0

        # Wait and then delete blue service
        sleep 60
        aws ecs delete-service \
          --cluster project-template-prod \
          --service project-template-prod-service \
          --force

        # Rename green service to main service
        # Note: AWS doesn't support renaming services, so we'll update the original
        aws ecs create-service \
          --cluster project-template-prod \
          --service-name project-template-prod-service \
          --task-definition project-template-prod:$NEW_REVISION \
          --desired-count 3 \
          --load-balancers targetGroupArn=${{ secrets.TARGET_GROUP_ARN }},containerName=api,containerPort=8080

        # Delete green service
        aws ecs delete-service \
          --cluster project-template-prod \
          --service project-template-prod-green \
          --force

    - name: Post-deployment verification
      run: |
        # Wait for service to stabilize
        sleep 120

        # Comprehensive health checks
        curl -f https://your-domain.com/health
        curl -f https://your-domain.com/api/v1/status
        curl -f https://your-domain.com/metrics

        # Test license integration
        response=$(curl -s https://your-domain.com/api/v1/features)
        if echo "$response" | jq -e '.features' > /dev/null; then
          echo "License integration verified"
        else
          echo "License integration test failed"
          exit 1
        fi

        echo "Production deployment successful"

    - name: Run production smoke tests
      run: |
        # Run comprehensive smoke tests
        python tests/smoke/production_tests.py

    - name: Notify deployment
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        text: |
          Production deployment ${{ job.status }}!
          Version: ${{ github.ref_name }}
          Environment: production
          URL: https://your-domain.com
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Kubernetes deployment option
  deploy-k8s:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && contains(github.event.inputs.environment, 'k8s')
    environment:
      name: kubernetes
      url: https://k8s.your-domain.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      uses: azure/k8s-set-context@v3
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets.KUBE_CONFIG }}

    - name: Deploy with Helm
      run: |
        VERSION=${{ github.event.inputs.version || github.ref_name }}

        # Add/update Helm repository if needed
        helm repo add project-template ./infrastructure/helm/project-template
        helm repo update

        # Deploy or upgrade
        helm upgrade --install project-template \
          project-template/project-template \
          --namespace project-template \
          --create-namespace \
          --set image.tag=$VERSION \
          --set ingress.hostname=k8s.your-domain.com \
          --set license.key=${{ secrets.LICENSE_KEY }} \
          --set license.product=project-template \
          --wait --timeout=10m

    - name: Verify Kubernetes deployment
      run: |
        # Check deployment status
        kubectl get deployments -n project-template
        kubectl get pods -n project-template
        kubectl get services -n project-template
        kubectl get ingress -n project-template

        # Wait for pods to be ready
        kubectl wait --for=condition=ready pod -l app=project-template -n project-template --timeout=300s

        # Health checks
        kubectl port-forward -n project-template svc/project-template-api 8080:8080 &
        sleep 10
        curl -f http://localhost:8080/health
        pkill -f port-forward

  # Rollback functionality
  rollback:
    runs-on: ubuntu-latest
    if: failure() && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v'))
    needs: [deploy-staging, deploy-production]
    environment:
      name: rollback

    steps:
    - name: Rollback ECS deployment
      run: |
        # Get previous task definition
        PREVIOUS_REVISION=$(aws ecs describe-services \
          --cluster project-template-prod \
          --services project-template-prod-service \
          --query 'services[0].taskDefinition' --output text | grep -o '[0-9]*$')

        ROLLBACK_REVISION=$((PREVIOUS_REVISION - 1))

        if [ $ROLLBACK_REVISION -gt 0 ]; then
          aws ecs update-service \
            --cluster project-template-prod \
            --service project-template-prod-service \
            --task-definition project-template-prod:$ROLLBACK_REVISION

          aws ecs wait services-stable \
            --cluster project-template-prod \
            --services project-template-prod-service

          echo "Rollback to revision $ROLLBACK_REVISION completed"
        else
          echo "No previous revision to rollback to"
          exit 1
        fi

    - name: Verify rollback
      run: |
        sleep 60
        curl -f https://your-domain.com/health
        echo "Rollback verification successful"

    - name: Notify rollback
      uses: 8398a7/action-slack@v3
      with:
        status: 'warning'
        channel: '#deployments'
        text: |
          ðŸš¨ Production rollback completed!
          Previous deployment failed and was rolled back.
          Please investigate the issue.
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}